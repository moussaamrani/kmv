cd /cygdrive/f/Workspace/Maude/KMV/
load syntax/model-checker.maude 
load syntax/mmOdCL.maude
load syntax/MMGDefinitions.maude


view @Class from TRIV to METAMODEL-CTORS is
  sort Elt to @Class .
endv

mod KERMETA-STMT-PREP is
	sort @Statement .
endm

mod KERMETA-SL-CTORS is
	pr METAMODEL-PROP .
	pr MGLIST{@NamedElement} * (sort MGList{@NamedElement} to MyList) .

	pr MGMAYBE{@Class} . 

	--- Operation & Parameters signature
	sort @Operation @Parameter @Variable @LocalVariable .
	subsort @Variable @Parameter < @LocalVariable < Vid .
	subsort @Operation @Parameter @LocalVariable < @StructuralFeature .
	op self : -> @LocalVariable .
	op operations : @Class -> MyList . --- of @Operation
	op isAbstract : @Operation -> Bool .
	op from : @StructuralFeature -> Maybe{@Class} .
	op containingOperation : @Parameter -> @Operation .
	op containingOperation : @Variable  -> @Operation .
   	op parameters : @Operation -> MyList . --- of @Parameter
	op variables : @Operation -> MyList .  --- of @Variable
				
	--- Label
	sort @Label @LabelNxt .
	op [_,_,_,_] : @Package @Class @Operation Nat -> @Label [ctor] .
	--- default label
	op [] : -> @Label .
	op <_,_> : @Label @Label -> @LabelNxt [ctor] .
	op nxt : @Label -> @LabelNxt .
	op labels : @Operation -> MyList . --- of @Label
endm

view @Label from TRIV to KERMETA-SL-CTORS is
  	sort Elt to @Label .
endv

view @Statement from TRIV to KERMETA-STMT-PREP is
 	sort Elt to @Statement .
endv

view @LocalVariable from TRIV to KERMETA-SL-CTORS is
	sort Elt to @LocalVariable .	
endv

view OCL-Type from TRIV to MGmOdCL is
    sort Elt to OCL-Type .
endv

mod KERMETA-STATEMENTS-MAP is
	pr MAP{@Label, @Statement} .
	pr MAP{@LocalVariable, OCL-Type} .
endm

mod KERMETA-SL is
	pr KERMETA-SL-CTORS .
	pr KERMETA-STATEMENTS-MAP .
	op statements : @Metamodel -> Map{@Label, @Statement} .
endm

--- ------------------------------------------------------------------------------------
--- Action Language Syntax
--- 
--- Body ::= [Stm]+
--- Stm  ::= lab: Stmt
--- Stmt ::= condStmt 
---       |  assignStmt | castStmt
---       |  instanceCreationStmt 
---       |  collStmt
---       |  returnStmt | callStmt 
--- CondStmt             ::= <if> exp
--- AssignStmt           ::= lhs := exp
--- InstanceCreationStmt ::= var := exp
--- ReturnStmt           ::= <return> | <return> exp
--- CallStmt             ::= call | var := call
--- Call                 ::= target.op(exp*)
--- ------------------------------------------------------------------------------------
mod KERMETA-AL is
	pr KERMETA-STMT-PREP .
	pr KERMETA-SL .
    pr METAMODEL-PROP .
                
	sort    @CondStmt @AssignStmt @InstanceCreationStmt @CallStmt @ReturnStmt .
	subsort @CondStmt @AssignStmt @InstanceCreationStmt @CallStmt @ReturnStmt < @Statement .
	
	op iff_      : OCL-Exp -> @CondStmt [ctor] .
   	op _.:=._      : OCL-Exp OCL-Exp -> @AssignStmt [ctor] .
   	op _ .:=. new`(_`) : @Variable @Class -> @InstanceCreationStmt [ctor] .
   	op return    : -> @ReturnStmt [ctor] .
   	op return_   : OCL-Exp -> @ReturnStmt [ctor] .
endm



mod KERMETA-DOMAIN is
	pr MGmOdCL .
	pr METAMODEL-PROP .
	pr KERMETA-SL-CTORS .
	---pr MAP{@LocalVariable, OclType} .
	sort Domain .
	op <_##_> : @Model Set{VarPair} -> Domain [ctor] .
		
endm

mod KERMETA-STACK is
	pr KERMETA-SL .
	pr KERMETA-STATEMENTS-MAP .
	pr MGMAYBE{@LocalVariable} .	
	
	sort StackEntry .
	op `(|_,_,_|`) : @Label Set{VarPair} Maybe{@LocalVariable} -> StackEntry .
endm

fmod STACK{X :: TRIV} is
	protecting BOOL .

	sorts NeStack{X} Stack{X} .
	subsort X$Elt  < NeStack{X} < Stack{X} .

	op NOPE : -> Stack{X} [ctor] .
	op _!!!_ : X$Elt Stack{X} -> NeStack{X} [ctor] .

	var E : X$Elt .
	var S : Stack{X} .
	eq (E !!! NOPE)  = E .
	
	op isEmpty_ : Stack{X} -> Bool .
	eq isEmpty(NOPE) = true .
	eq isEmpty(S)    = false [owise] .
	
endfm



view StackEntry from TRIV to KERMETA-STACK is
	sort Elt to StackEntry .
endv

mod KERMETA-CONFIGURATION is
	pr KERMETA-SL .
	pr STACK{StackEntry} .
	pr KERMETA-DOMAIN .
	
	sort KConfig .
	op <|_,_,_,_|> : @Label Stack{StackEntry} Domain Nat -> KConfig .
	
	var LAB : @Label .
	var S : Stack{StackEntry} .
	var N : Nat .
	var D : Domain .
	
	op finished_ : KConfig -> Bool .
	eq finished(<| [], S, D, N |>) = isEmpty(S) .
	eq finished(<| LAB, S, D, N |>) = false [owise] .
endm
mod KERMETA is

	pr KERMETA-AL .
	pr KERMETA-CONFIGURATION .
	
	
	var N : Nat .
	vars LAB LABNxt LABE LABT LABNULL : @Label .
	vars D : Domain .
	vars VPSET VPSETT : Set{VarPair} .
	vars M MP : @Model .
	vars MM : @Metamodel .
	var SFIS : Set{@StructuralFeatureInstance} .
	vars S : Stack{StackEntry} .
	vars E RES : OCL-Exp .
	vars MYVAR : @Variable .
	var MAYBEVAR : Maybe{@LocalVariable} .
	var CLASS : @Class .
	var OBJSET : Set{@Object} .
	var SE : StackEntry .
	
	op newOid : Nat -> Oid .
	
	var VAR : @Variable .
	eq newOid(N) = qid("O" + string(N, 10)) .
	
	
	op exec_ : KConfig -> KConfig .
	op exec_ : KConfig -> KConfig .
	ceq exec(<| LAB, S, < M ## VPSET >, N |>) = <| LABT, S, < M ## VPSET >, N |> 
		if  iff( E ) := statements( meta(M) ) [ LAB ] /\ < LABT , LABE > := nxt(LAB)
			 /\ true = << E ; env(VPSET) ; M >> 	
	.
	ceq exec(<| LAB, S, < M ## VPSET >, N |>) = <| LABE, S, < M ## VPSET >, N |> 
		if  iff( E ) := statements( meta(M) ) [ LAB ] /\ 
			< LABT , LABE > := nxt(LAB) /\ false = << E ; env(VPSET) ; M >> 
	.
	ceq exec(<| LAB, S, < MM { OBJSET } ## VPSET >, N |>) = <| LABNxt, S, < MM { complete(< newOid(N) : CLASS | empty >) OBJSET } ## (putVar(MYVAR <- newOid(N), VPSET)) >, (N + 1) |>
			if  MYVAR .:=. new ( CLASS ) := statements( MM ) [ LAB ] /\ 
			< LABNxt , LABNULL > := nxt(LAB)
	.
	ceq exec(<| LAB, (| LABNxt , VPSETT, null |) !!! S, < M ## VPSET >, N |>) = <| LABNxt, S, < M ## VPSETT >, N |> if
		return :=  statements( meta(M) ) [ LAB ]
	.
	ceq exec(<| LAB, (| LABNxt , VPSETT, MYVAR |) !!! S, < M ## VPSET >, N |>) = <| LABNxt, S, < M ## VPSETT >, N |> if
		return( E ) :=  statements( meta(M) ) [ LAB ] /\
		RES := << E ; env(VPSET) ; M >>
	. --- evaluate E within VPSET, then update MYVAR inside VPSETT
		
endm