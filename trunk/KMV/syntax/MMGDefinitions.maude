**** Printable line length ***************************************************---thesis-------
******************************************************************************---thesis-------
set show advisories on .

mod MGmOdCL is		
	pr mOdCL * (--- Renamings of CONFIGURATION module elements
				sort Cid           to @Class,
				sort Object        to @Object,
				sort Attribute     to @StructuralFeatureInstance,
				sort AttributeSet  to Set{@StructuralFeatureInstance},
				op none : -> AttributeSet to empty,
				--- Renamings of mOdCL elements
				sort AttributeName to @StructuralFeature,
				sort Enum to @EnumerationInstance,
				sort BasicType to @DataTypeInstance,
				--- Renamings of _,_ due to conflict with prefix notation 
				op _`,_ : AttributeSet AttributeSet -> AttributeSet to _#_ [prec 21 gather (e E)], 
				op _:_ to _:_ [prec 20 gather (e E)],
				op string : Qid -> String to qid2String, 
                op qid : String -> Qid to string2Qid ) .	
	
	--- Relationship established by Ecore			
	subsort @EnumerationInstance < @DataTypeInstance . 
      
   	--- OrderedSet operations that are not defined in OCL
	eq asSequence(OrderedSet{L:List{OclExp}}) = Sequence{L:List{OclExp}} .
    eq exclude(I:OclType, OrderedSet{L:List{OclExp}}) 
      = OrderedSet{delete-all$L(I:OclType, L:List{OclExp})} .

	--- Dependency with the literals operation
	--- op literals : @Enumeration -> List{OclExp} . --- Of @EnumerationInstance .
	
	--- Another dependency with the null value applies (see below)
	
	--- More dependencies with the METAMODEL-PROP (see at the end of the module)
	
	--- Finally, several renamings are applied accordingly to the renamings performed in mOdCL
	--- In this file we can find this kind of renamings in the MYQID, MGMODEL-CHECKER, 
	---    MGMETA-LEVEL, MODELPARSER modules
endm

mod METAMODEL-CTORS is
	pr MGmOdCL .
	
	*** METAMODEL ELEMENTS *** 
	--- We create a sort for every (Ecore) metamodel element
	--- We use CONFIGURATION (and mOdCL) elements renamed where possible
	
	--- Sorts not included in mOdCL
	sort @NamedElement .
	sort @Metamodel .
	sort @Package .
	sort @Classifier .
	sort @Attribute .
	sort @Reference .
	sort @DataType .
	sort @Enumeration .
	
	--- Subsort relationships
	subsorts OclVoid < @Metamodel @Package @Classifier @StructuralFeature < @NamedElement .
	subsorts OclVoid < @Class @DataType < @Classifier .
	subsorts OclVoid < @Attribute @Reference < @StructuralFeature .
	subsorts OclVoid < @Enumeration < @DataType .
	
	subsorts OclVoid < Set{@StructuralFeatureInstance} 
	                   @StructuralFeatureInstance Set{@AttributeInstance} Set{@ReferenceInstance} Vid 
	                   LetExp @AttributeInstance @ReferenceInstance EmptySet Collection Q-Assoc Arg 
	                   Oid Set Bag OrdSet Sequence Q-AssocPair @DataTypeInstance Float String Bool @EnumerationInstance 
	                   FiniteFloat Char PosRat Zero NzNat .
    op _.+._ : OclVoid OclVoid -> OclVoid [ditto] .
    op _.-._ : OclVoid OclVoid -> OclVoid [ditto] .
    op _.*._ : OclVoid OclVoid -> OclVoid [ditto] .
    op _./._ : OclVoid OclVoid -> OclVoid [ditto] .
    op _.>._ : OclVoid OclVoid -> OclVoid [ditto] .
    op _.<._ : OclVoid OclVoid -> OclVoid [ditto] .
    op _.>=._ : OclVoid OclVoid -> OclVoid [ditto] .
    op _.<=._ : OclVoid OclVoid -> OclVoid [ditto] .
    op .max. : OclVoid OclVoid -> OclVoid [ditto] .
    op .min. : OclVoid OclVoid -> OclVoid [ditto] .
    op _:_ : OclVoid OclType -> OclVoid [ditto] .
    op _#_ : OclVoid OclVoid -> OclVoid [ditto] .
    op insertAt : Int OclType OclVoid -> OclVoid .
    
    op type : OclVoid -> OclVoid .
    op meta : OclVoid -> OclVoid .
    
	--- Basic data types
	op @String : -> @DataType .
	op @Int : -> @DataType .
	op @Bool : -> @DataType .
	op @Float : -> @DataType .
	op @DataType : -> @DataType .
		
	*** MODEL ELEMENTS *** 	
	
	sort @Model .
	op _`{_`} : @Metamodel Set{@Object} -> @Model [ctor] .
		
	sort Set{@Object} .
	subsort @Object < Set{@Object} < Configuration .
	op __ : Set{@Object} Set{@Object} -> Set{@Object} [ctor ditto] .
	op none : -> Set{@Object} [ctor ditto] .
	
	subsort @AttributeInstance @ReferenceInstance < @StructuralFeatureInstance .
	
	sort @AttributeInstance .
	op _:_ : @Attribute OclType -> @AttributeInstance [ctor ditto] .	
	
	sort @ReferenceInstance .
	--- OclType includes collections defined over BasicTypes and Oids 
	op _:_ : @Reference OclType -> @ReferenceInstance [ctor ditto] .
	
	sort Set{@AttributeInstance} .
	subsort @AttributeInstance < Set{@AttributeInstance} < Set{@StructuralFeatureInstance} .
	op _#_ : Set{@AttributeInstance} Set{@AttributeInstance} 
		-> Set{@AttributeInstance} [ctor ditto] .
	
	sort Set{@ReferenceInstance} .
	subsort @ReferenceInstance < Set{@ReferenceInstance} < Set{@StructuralFeatureInstance} .
	op _#_ : Set{@ReferenceInstance} Set{@ReferenceInstance} 
		-> Set{@ReferenceInstance} [ctor ditto] .
	
	sort EmptySet .
	subsorts EmptySet < Set{@ReferenceInstance} Set{@AttributeInstance} .
	op _#_ : EmptySet EmptySet -> EmptySet [ctor ditto] .
	op empty : -> EmptySet [ctor ditto] .
	
	--- Operator @Object (equivalent to (Ecore) EObject)
	op @Object : -> @Class .
endm

mod MYQID is
   pr MGmOdCL .
   pr QID 
	    * (op _xor_ : Nat Nat -> Nat to _xorN_,
           op _|_   : Nat Nat -> Nat  to _|N_,    
           op _+_   : Nat Nat -> Nat to _+N_,
           op _*_   : Nat Nat -> Nat to _*N_,
           op _<_   : Nat Nat -> Bool to _<N_,
           op _<=_  : Nat Nat -> Bool to _<=N_,
           op _>=_  : Nat Nat -> Bool to _>=N_,
           op _>_   : Nat Nat -> Bool to _>N_,
	       op _<_  : String String -> Bool to _<S_,   
           op _<=_ : String String -> Bool to _<=S_,   
           op _>_  : String String -> Bool to _>S_,   
           op _>=_ : String String -> Bool to _>=S_,  
           op _+_  : String String -> String to _+S_,
           
           op string : Qid -> String to qid2String, 
           op qid : String -> Qid to string2Qid) .
           
    --- We use quoted identifiers as object identifiers            
	subsort Qid < Oid .
endm

mod MGMAYBE{X :: TRIV} is
	pr MGmOdCL .

	sort Maybe{X} .
	subsort X$Elt OclVoid < Maybe{X} .
endm

--- List defined for gathering the properties of metamodel elements
fmod MGLIST{X :: TRIV} is
    pr EXT-BOOL .
    
    sort MGNeList{X} MGList{X} .
    subsort X$Elt < MGNeList{X} .
    subsort EmptyList MGNeList{X} < MGList{X} .
    
    sort EmptyList .
    op nil : -> EmptyList [ctor] .
---(
    op __ : EmptyList EmptyList -> EmptyList [ctor assoc id: nil prec 25] .
    op __ : MGList{X} MGList{X} -> MGList{X} [ctor ditto] .
---)
    op __ : X$Elt MGList{X} -> MGList{X} [ctor prec 25] .
    eq E nil = E .
    
    var E E' : X$Elt .
    vars A L : MGList{X} .

    op append : EmptyList EmptyList -> EmptyList .
    op append : MGList{X} MGList{X} -> MGList{X} .
---(
    eq append(A, L) = A L .
---)
    eq append(E A, L) = E append(A, L) .
    eq append(E, L) = E L .
    eq append(nil, L) = L .

    op occurs : X$Elt MGList{X} -> Bool .
    eq occurs(E, nil) = false .
    eq occurs(E, E') = E == E' .
    eq occurs(E, E' L) = E == E' or-else occurs(E, L) .

----    op _in_ : X$Elt MGList{X} -> Bool .
----    eq (E in L) =  occurs(E, L) .
  
    op reverse : EmptyList -> EmptyList .
    op reverse : MGList{X} -> MGList{X} .
    eq reverse(L) = $reverse(L, nil) .

    op $reverse : EmptyList EmptyList -> EmptyList .
    op $reverse : MGList{X} MGList{X} -> MGList{X} .
    eq $reverse(nil, A) = A .
    eq $reverse(E, A) = E A .
    eq $reverse(E L, A) = $reverse(L, E A).
endfm

view @NamedElement from TRIV to METAMODEL-CTORS is
  sort Elt to @NamedElement .
endv

view @Reference from TRIV to METAMODEL-CTORS is
  sort Elt to @Reference .
endv

view @Attribute from TRIV to METAMODEL-CTORS is
  sort Elt to @Attribute .
endv

view @Metamodel from TRIV to METAMODEL-CTORS is
  sort Elt to @Metamodel .
endv

view @Package from TRIV to METAMODEL-CTORS is
  sort Elt to @Package .
endv

view @DataType from TRIV to METAMODEL-CTORS is
  sort Elt to @DataType .
endv

mod METAMODEL-PROP is
	pr METAMODEL-CTORS .
	pr MYQID .
	pr MGLIST{@NamedElement} * (sort MGList{@NamedElement} to MyList) .
	pr MGMAYBE{@Package} + MGMAYBE{@Metamodel} + MGMAYBE{@DataType} + MGMAYBE{@Reference} 
	   + MGMAYBE{@Attribute} .  
	  
	var MM : @Metamodel .
	var P : @Package .
	var OBJSET : Set{@Object} .
	var CLF : @Classifier .
	var C C2 : @Class .
	var OBJ : @Object .
	var O : Oid .
	var SF SF2 : @StructuralFeature .
	var REF : @Reference .
	var ATT : @Attribute .
	var SFI : @StructuralFeatureInstance .
	var SFIS : Set{@StructuralFeatureInstance} .
	var ATTIS : Set{@AttributeInstance} .
	var REFIS : Set{@ReferenceInstance} .
	vars DT DT2 : @DataType .
	vars DTI DTI1 DTI2 : @DataTypeInstance .
	vars I1 I2 : Int .
	var L : MyList .
	var LO : List{OclExp} .
	var OCLTYPE : OclType .
	var CONF : Configuration .
	var VALUE : OclType .
	
	*** METAMODEL PROPERTIES ***
	
	--- NamedElement 
	op name : @NamedElement -> String .	
	
	--- Metamodel 
	op packages : @Metamodel -> MyList . --- Of @Package
	
	--- Packages 
	op metamodel : @Package -> @Metamodel .
	op superPackage : @Package -> Maybe{@Package} . 
	op subPackages : @Package -> MyList . --- Of @Package
	op classes : @Package -> MyList . --- Of @Class
	
	--- Classifiers
	op package : @Classifier -> Maybe{@Package} . 
	--- For data types that are not enumerations
	eq package(DT) = null [owise] .
	
	--- Classes
	op superTypes : @Class -> MyList . --- Of @Class
	op references : @Class -> MyList . --- Of @Reference
	op attributes : @Class -> MyList . --- Of @Attribute
	op isAbstract : @Class -> Bool .
	
	--- StructuralFeatures
	op type : @StructuralFeature -> @Classifier .
	op type : @Attribute -> @DataType [ditto] .
	op type : @Reference -> @Class [ditto] .
	op lowerBound : @StructuralFeature -> Int .
	op upperBound : @StructuralFeature -> Int .
	op containingClass : @StructuralFeature -> @Class .
	op isOrdered : @StructuralFeature -> Bool .
	op isUnique : @StructuralFeature -> Bool .
	
	--- Attributes
	op specificDefaultValue : @Attribute -> OclType . --- Of @DataTypeInstance
	eq specificDefaultValue(ATT) = null [owise] .
	op isId : @Attribute -> Bool .
	
	--- References		
	op opposite : @Reference -> Maybe{@Reference} . 
	op isContainment : @Reference -> Bool .
	
	--- Enumerations
	op defaultValue : @Enumeration -> @EnumerationInstance . --- [ditto] .
	op literals : @Enumeration -> List{OclExp} . --- Of @EnumerationInstance .
	--- List{OclExp} is taken from mOdCL 
		
	--- Enumeration Instances
	op meta : @EnumerationInstance -> @Enumeration .
	
	*** METAMODEL DERIVED PROPERTIES AND OPERATIONS ***
	
	--- Metamodels
	op allClasses : @Metamodel -> MyList . --- Of @Class
	eq allClasses(MM) = classesAux(allPackages(MM)) .
	
	op allPackages : @Metamodel -> MyList . --- Of @Package
	eq allPackages(MM) = append(packages(MM), allSubPackages(packages(MM))) .
	
	--- Packages
	op allSubPackages : MyList -> MyList . --- Of @Package (both) .
	eq allSubPackages(nil) = nil .
	eq allSubPackages(P) = append(subPackages(P), allSubPackages(subPackages(P))) .
	eq allSubPackages((P L)) = append(append(subPackages(P), allSubPackages(subPackages(P))), allSubPackages(L)) .
	
	op allClasses : @Package -> MyList . --- Of @Class
	eq allClasses(P) = append(classes(P), classesAux(allSubPackages((P nil)))) .
	
	op classesAux : MyList -> MyList . --- Of @Package, @Class  
	eq classesAux(nil) = nil .	
    eq classesAux(P) = classes(P) .
    eq classesAux(P L) = append(classes(P), classesAux(L)) .

	--- DataTypes
	--- This operation is also defined for enumerations in the metamodels equations
	op defaultValue : @DataType -> @DataTypeInstance .
    eq defaultValue(@String)= "" .
    eq defaultValue(@Int)= 0 .
	eq defaultValue(@Bool)= false .
	eq defaultValue(@Float)= 0.0 .
	eq defaultValue(DT)= null [owise] .
	
	--- DataTypes and DataTypesInstances
	--- This operation is also defined for enumerations in the metamodels equations
	op metaAux : @DataTypeInstance -> @DataType .
	eq metaAux(S:String) = @String .
	eq metaAux(I:Int) = @Int .
	eq metaAux(B:Bool) = @Bool .
	eq metaAux(S:Float) = @Float .
	eq metaAux(DTI) = @DataType [owise] .
		
	op subTypeOf : @DataType @DataType -> Bool .
	eq subTypeOf(DT, @DataType) = true .
	eq subTypeOf(DT, DT) = true .
	eq subTypeOf(DT, DT2) = false [owise] .	
		
	--- Classifiers
	op metamodel : @Classifier -> Maybe{@Metamodel} . 
	eq metamodel(CLF) = if (package(CLF) == null) then null else metamodel(package(CLF)) fi .
	eq metamodel(CLF) = metamodel(package(CLF)) .
	
	--- Classes
	op structuralFeatures : @Class -> MyList . --- Of @StructuralFeature
	eq structuralFeatures(C) = append(attributes(C), references(C)) .
	
	op allSuperTypes : MyList -> MyList . --- Of @Class (both)
	eq allSuperTypes(nil) = nil .
	eq allSuperTypes(C) = append(superTypes(C), allSuperTypes(superTypes(C))) .
	eq allSuperTypes(C L) = append(append(superTypes(C), allSuperTypes(superTypes(C))), allSuperTypes(L)) .
	
	op allReferences : MyList -> MyList . --- Of @Class, @Reference
	eq allReferences(nil) = nil .
	eq allReferences(C) = append(references(C), allReferences(superTypes(C))) .
	eq allReferences(C L) = append(append(references(C), allReferences(superTypes(C))), allReferences(L)) .

	op containmentReferences : @Class -> MyList . --- Of @References
	eq containmentReferences(C) = containmentReferences(allReferences((C nil))) .
	op containmentReferences : MyList -> MyList . --- Of @References (both)
	eq containmentReferences(nil) = nil .
    eq containmentReferences(REF) 
      = if (isContainment(REF)) 
        then REF 
        else nil 
        fi .
    eq containmentReferences(REF L) 
      = if (isContainment(REF)) 
        then (REF containmentReferences(L))
        else containmentReferences(L) 
        fi .
		
	op allAttributes : MyList -> MyList . --- Of @Class, @Attribute 
	eq allAttributes(nil) = nil .
	eq allAttributes(C) = append(attributes(C), allAttributes(superTypes(C))) .
	eq allAttributes(C L) = append(append(attributes(C), allAttributes(superTypes(C))), allAttributes(L)) .
	
	op allStructuralFeatures : @Class -> MyList . --- Of @StructuralFeature
	eq allStructuralFeatures(C) = append(allAttributes(C nil), allReferences(C nil)) .
	
	op superTypeOf : @Class @Class -> Bool .
	eq superTypeOf(@Object, C2) = true .	
	eq superTypeOf(C, C2) = 
		((name(C) == "EObject" and-then name(package(C)) == "ecore") 
		or-else (C in allSuperTypes(C2 nil))) 
	  [owise] .
	--- This equation is equivalent to:
	--- eq subTypeOf(C, EObject@ecore) = true .
	--- However, the Ecore Metamodel is not imported yet
	
	op subTypeOf : @Class @Class -> Bool .	
	eq subTypeOf(C, C2) = superTypeOf(C2, C) . 
	
	op idAttribute : @Class -> Maybe{@Attribute} . 
	eq idAttribute(C) = idAttribute(allAttributes(C nil)) .
	
	op idAttribute : MyList -> Maybe{@Attribute} . --- Of @Attribute
	eq idAttribute(nil) = null .	
    eq idAttribute(ATT) = if isId(ATT) then ATT else null fi .
    eq idAttribute(ATT L) = if isId(ATT) then ATT else idAttribute(L) fi .
		
	--- StructuralFeatures
	op isMany : @StructuralFeature -> Bool .
	eq isMany(SF) =	(2 <=Card upperBound(SF)) .
	
	op isRequired : @StructuralFeature -> Bool .
	eq isRequired(SF) = (1 <=Card lowerBound(SF)) .
	
	op metamodel : @StructuralFeature -> @Metamodel .
	eq metamodel(SF) = metamodel(package(containingClass(SF))) .
	
	op defaultValue : @StructuralFeature -> OclType .
		
	--- Attributes
	op defaultValue : @Attribute -> OclType [ditto] . --- Of @DataTypeInstance
	eq defaultValue(ATT) 
	  = if not (specificDefaultValue(ATT) == null) 
	    then specificDefaultValue(ATT)
	    else if (isMany(ATT) and-then isRequired(ATT))
	         then if isOrdered(ATT) 
	              then if isUnique(ATT) 
	                   then OrderedSet{ defaultValue(type(ATT)) # mt-ord }  
	                   else Sequence{ defaultValue(type(ATT)) # mt-ord } fi
	              else if isUnique(ATT) 
                       then Set{ defaultValue(type(ATT)) }  
                       else Bag{ defaultValue(type(ATT)) } fi fi 
	         else if isMany(ATT) 
	              then if isOrdered(ATT) 
	                   then if isUnique(ATT) 
	                        then OrderedSet{ mt-ord }  
	                        else Sequence{ mt-ord } fi
	                   else if isUnique(ATT) 
	                        then Set{ mt }  
	                        else Bag{ mt } fi fi 
	              else if (isRequired(ATT)) 
	                   then defaultValue(type(ATT)) 
	                   else null fi fi fi fi .
		
	--- References
	op defaultValue : @Reference -> OclType [ditto] . --- Of Oid
	eq defaultValue(REF) 
	  = if isMany(REF) 
	    then if isOrdered(REF) 
	         then if isUnique(REF) 
	              then OrderedSet{}  
	              else Sequence{} fi
	         else if isUnique(REF) 
	              then Set{}  
	              else Bag{} fi fi 
	    else null fi .
		
	op isContainer : @Reference -> Bool . 
	eq isContainer(REF)= isContainment(opposite(REF)) .
	
---(
	--- DataType Instances
	op meta : OclType -> Maybe{@DataType} . --- Of @DataTypeInstance 
	eq meta(VALUE) = metaListAux(<< VALUE -> asSequence() >>) .
---)
		
	op metaListAux : Sequence -> Maybe{@DataType} . --- Of @DataTypeInstance
	eq metaListAux(Sequence{mt-ord}) = null .
	eq metaListAux(Sequence{DTI1 # mt-ord}) = metaAux(DTI1) .
	eq metaListAux(Sequence{DTI1 # DTI2 # LO}) 
	  = if (metaAux(DTI1) == metaListAux(Sequence{DTI2 # LO}))
	    then metaAux(DTI1)
	    else null fi .	
	
	--- StructuralFeature Instances	
	op meta : @StructuralFeatureInstance -> @StructuralFeature .
	eq meta(SF : VALUE) = SF .
	
	op isOrdered : @StructuralFeatureInstance -> Bool .
	eq isOrdered(SFI) = isOrdered(meta(SFI)) .
	
	op isUnique : @StructuralFeatureInstance -> Bool .
	eq isUnique(SFI) = isUnique(meta(SFI)) .
	
	op isOrdered : OclType -> Bool .
	eq isOrdered(B:Bag) = false .
	eq isOrdered(S:Set) = false .
	eq isOrdered(VALUE) = true [owise] .
	
	op isUnique : OclType -> Bool .
	eq isUnique(S:Sequence) = false .
	eq isUnique(B:Bag) = false .
	eq isUnique(VALUE) = true [owise] .
	
	op isMany : OclType -> Bool .
	eq isMany(COL:Collection) = true .
	eq isMany(VALUE) = false [owise] .
	
	op atts : Set{@StructuralFeatureInstance} -> Set{@AttributeInstance} .
	eq atts((ATTIS # REFIS)) = ATTIS .
	
	op refs : Set{@StructuralFeatureInstance} -> Set{@ReferenceInstance} .
	eq refs((ATTIS # REFIS)) = REFIS .
	
	op get : Set{@StructuralFeatureInstance} @StructuralFeature -> OclType . 
	eq get((SF : VALUE # SFIS), SF) = VALUE .
	eq get(SFIS, SF) = null [owise] .
	
	--- Objects	
	op meta : @Object -> @Class .
	eq meta(< O : C | SFIS >) = C .
	
	op get : @Object @StructuralFeature -> OclType . 
	eq get(< O : C | (SF : VALUE # SFIS) >, SF) = VALUE .
	eq get(OBJ, SF) = null [owise] .
	
	--- The complete operation adds to a object all the structural features-value pairs (with 
	--- their default value) that are missing
	op complete : @Object -> @Object .
	eq complete(< O : C | SFIS >) = complete(< O : C | SFIS >, allStructuralFeatures(C)) .
	op complete : @Object MyList -> @Object .
    eq complete(< O : C | SF : VALUE # SFIS >, SF) 
      = < O : C | SF : VALUE # SFIS > .
    eq complete(< O : C | SF : VALUE # SFIS >, (SF L)) 
      = complete(< O : C | SF : VALUE # SFIS >, L) .
    eq complete(< O : C | SFIS >, SF) 
      = < O : C | SF : defaultValue(SF) # SFIS > [owise] .
    eq complete(< O : C | SFIS >, (SF L)) 
      = complete(< O : C | SF : defaultValue(SF) # SFIS >, L) [owise] .
	eq complete(< O : C | SFIS >, nil) = < O : C | SFIS > .
			
	--- Model
	op meta : @Model -> @Metamodel .
	eq meta(MM { OBJSET }) = MM .
	
	op objectsSet : @Model -> Set{@Object} .
	eq objectsSet(MM { OBJSET }) = OBJSET .
	
	--- Cardinality
	op * : -> Int .
	eq * = -1 .
	
	op maxCard : Int Int -> Int [comm] .
	eq maxCard(-1, I1) = -1 .
	eq maxCard(I1, I2) = max(I1, I2) [owise] .
	
	op minCard : Int Int -> Int [comm] .
	eq minCard(-1, I1) = I1 .
	eq minCard(I1, I2) = min(I1, I2) [owise] .
	
	op _<=Card_ : Int Int -> Bool .
	eq I1 <=Card -1 = true .
	eq -1 <=Card I2 = (I2 == -1) . 
	eq I1 <=Card I2 = I1 <= I2 [owise] .
	
---(
	*** mOdCL OPERATION ADAPTATIONS ***
	
	--- Eval now can be applied over @Model terms
	op eval : OclExp Msg @Model -> OclExp .
	eq eval( EXP:OclExp , env(VARS:Set{VarPair}) , MM { OBJSET } ) = 
		if (VARS:Set{VarPair} == empty)
		then eval-aux(EXP:OclExp, env(self <- foo-self) OBJSET, none ) 
		else eval-aux(EXP:OclExp, env(VARS:Set{VarPair}) OBJSET, none ) fi .
	 	
	op <<_;_>> : OclExp @Model -> OclExp .
    --- We cannot use the same <<_:_>> mOdCL operator due to conflicts 
    --- (it returns the invalid value)
    eq << EXP:OclExp ; MM { OBJSET } >> = ---<< EXP:OclExp : OBJSET >> .
    	eval-aux(EXP:OclExp, env(empty) OBJSET, none ) .
	
	--- The second argument are the context avriables
	op <<_;_;_>> : OclExp Msg @Model -> OclExp .
	eq << EXP:OclExp ; env(VARS:Set{VarPair}) ; MM { OBJSET } >> = 
		eval-aux(EXP:OclExp, env(VARS:Set{VarPair}) OBJSET, none ) .
		
  	--- Operation required by mOdCL
	--- Note that for this OCL operation a class is subclass of itself 
	--- op isSubClass : Cid Cid -> Bool .
	eq isSubClass(C, C2) = ((C == C2) or-else subTypeOf(C,C2)) .

	--- To handle not (name-)qualified attributes in OCL expressions
	--- op getAttr : Universal Configuration -> Universal [poly (1 0)] .
	ceq get-attr(O (. SF).OclAttr, < O : C | SF2 : OCLTYPE # SFIS > CONF) 
	  = OCLTYPE
	  if (name(SF) == name(SF2)) .
---)
endm

red 97 .

mod MGMODEL-CHECKER is
   pr METAMODEL-CTORS .
   pr MODEL-CHECKER 
	    * (op _xor_ : Nat Nat -> Nat to _xorN_,
           op _|_   : Nat Nat -> Nat  to _|N_,    
           op _+_   : Nat Nat -> Nat to _+N_,
           op _*_   : Nat Nat -> Nat to _*N_,
           op _<_   : Nat Nat -> Bool to _<N_,
           op _<=_  : Nat Nat -> Bool to _<=N_,
           op _>=_  : Nat Nat -> Bool to _>=N_,
           op _>_   : Nat Nat -> Bool to _>N_,
           op _<_  : String String -> Bool to _<S_,   
           op _<=_ : String String -> Bool to _<=S_,   
           op _>_  : String String -> Bool to _>S_,   
           op _>=_ : String String -> Bool to _>=S_,  
           op _+_  : String String -> String to _+S_,
           op string : Qid -> String to qid2String, 
           op qid : String -> Qid to string2Qid) .
                
	subsort @Model < State .
	var MODEL : @Model .
	var PROP : Prop .
	eq MODEL |= PROP = false [owise] .
endm 

mod MODELCONFORMANCE is
	pr METAMODEL-PROP .

	
	vars MM : @Metamodel .
	vars MODEL : @Model .
	vars C C' : @Class .
	vars O SRC : Oid .
	vars OBJSET : Set{@Object} .
	vars SFS SFS' : Set{@StructuralFeatureInstance} .
	vars ATTIS : Set{@AttributeInstance} .
	vars REFIS : Set{@ReferenceInstance} .
	var ATT : @Attribute .
	var REF : @Reference .
	vars ATTS REFS : MyList .
	var VALUE : OclType .
	
	var LO : List{OclExp} .
	var SEQ : Sequence .
	

---(
	op validModel : @Model -> Bool .
	eq validModel(MODEL) = validModelAux(MODEL, MODEL) .
	
	op isEcore : @Metamodel -> Bool .
	eq isEcore(MM) = name(MM) == "Ecore" .
	op size : OclType -> Nat .
	eq size(VALUE) = << VALUE -> asSequence() -> size() >> .
	
	op validModelAux : @Model @Model -> Bool .
	eq validModelAux(MM { none }, MODEL) = true .
	eq validModelAux(MM { < O : C | (ATTIS # REFIS) > OBJSET }, MODEL) =
		--- Ecore is imported in every metamodel
		(((((metamodel(C) == MM) or-else isEcore(metamodel(C))) 
		and-then validReferences(allReferences(C), < O : C | REFIS >, MODEL)) 
		and-then validAttributes(allAttributes(C), < O : C | ATTIS >)) 
		and-then validModelAux(MM { OBJSET }, MODEL)) .
	--- Note that it returns false when there is a containment reference 
	--- in the metamodel which type is EObject (o @Object).
	eq validModelAux(MM { OBJSET }, MODEL) = false [owise] .
	
	--- Every structural feature of its metaclass (and superclasses) must be 
	--- included in the definition of an object, and only those ones.
	op validAttributes : MyList @Object -> Bool .
	eq validAttributes(nil, < O : C | empty >) = true .
    eq validAttributes(ATT, < O : C | (ATT : VALUE # ATTIS) >) = 
        (((((((isUnique(ATT) == isUnique(VALUE)) 
        and-then (isOrdered(ATT) == isOrdered(VALUE)))
        and-then (isMany(ATT) == isMany(VALUE))) 
        and-then (lowerBound(ATT) <=Card size(VALUE))) 
        and-then (size(VALUE) <=Card upperBound(ATT))) 
        and-then (<< VALUE -> asSequence() -> isEmpty() >> or-else  
                   subTypeOf(meta(VALUE), type(ATT))))) .
    eq validAttributes((ATT ATTS), < O : C | (ATT : VALUE # ATTIS) >) = 
        (((((((isUnique(ATT) == isUnique(VALUE)) 
        and-then (isOrdered(ATT) == isOrdered(VALUE)))
        and-then (isMany(ATT) == isMany(VALUE))) 
        and-then (lowerBound(ATT) <=Card size(VALUE))) 
        and-then (size(VALUE) <=Card upperBound(ATT))) 
        and-then (<< VALUE -> asSequence() -> isEmpty() >> or-else  
                   subTypeOf(meta(VALUE), type(ATT)))) 
        and-then validAttributes(ATTS, < O : C | ATTIS >)) .
	eq validAttributes(ATTS, < O : C | ATTIS >) = false [owise] .
	
	op validReferences : MyList @Object @Model -> Bool .
	eq validReferences(nil, < O : C | empty >, MODEL) = true .
    eq validReferences(REF, < O : C | (REF : VALUE # REFIS) >, MODEL) = 
        ((((((((isUnique(REF) == isUnique(VALUE)) 
        and-then (isOrdered(REF) == isOrdered(VALUE))) 
        and-then (isMany(REF) == isMany(VALUE)) )
        and-then (lowerBound(REF) <=Card size(VALUE))) 
        and-then (size(VALUE) <=Card upperBound(REF)))
        and-then validRefType( << VALUE -> asSequence() >>, type(REF), MODEL)) 
        and-then ((opposite(REF) == null) or-else 
          validOpposites(<< VALUE -> asSequence() >>, opposite(REF), O, MODEL)))) .
    eq validReferences((REF REFS), < O : C | (REF : VALUE # REFIS) >, MODEL) = 
        ((((((((isUnique(REF) == isUnique(VALUE)) 
        and-then (isOrdered(REF) == isOrdered(VALUE))) 
        and-then (isMany(REF) == isMany(VALUE)) )
        and-then (lowerBound(REF) <=Card size(VALUE))) 
        and-then (size(VALUE) <=Card upperBound(REF)))
        and-then validRefType( << VALUE -> asSequence() >>, type(REF), MODEL)) 
        and-then ((opposite(REF) == null) or-else 
          validOpposites(<< VALUE -> asSequence() >>, opposite(REF), O, MODEL))) 
        and-then validReferences(REFS, < O : C | REFIS >, MODEL)) .
	eq validReferences(REFS, < O : C | REFIS >, MODEL) = false [owise] .
	
	op validRefType : Sequence @Class @Model -> Bool .
	eq validRefType(Sequence{mt-ord}, C, MODEL) = true .
	eq validRefType(Sequence{O # LO}, C', MM { < O : C | SFS > OBJSET }) =
		(isSubClass(C, C') 
		and-then validRefType(Sequence{LO}, C', 
		  MM { < O : C | SFS > OBJSET })) .
	eq validRefType(SEQ, C, MODEL) = false [owise] .
	
	op validOpposites : Sequence @Reference Oid @Model -> Bool .
	eq validOpposites(Sequence{mt-ord}, REF, SRC, MODEL) = true .
	eq validOpposites(Sequence{O # LO}, REF, SRC, 
	                  MM { < O : C | (REF : VALUE # SFS) > OBJSET }) =
		(<< VALUE -> asSequence() -> includes(SRC) >> 
		and-then validOpposites(Sequence{LO}, REF, SRC, 
          MM { < O : C | (REF : VALUE # SFS) > OBJSET })) .
	eq validOpposites(SEQ, REF, O, MODEL) = false [owise] .
---)
endm

mod MGMETA-LEVEL is
   pr META-LEVEL 
        * (op _xor_ : Nat Nat -> Nat to _xorN_,
           op _|_   : Nat Nat -> Nat  to _|N_,    
           op _+_   : Nat Nat -> Nat to _+N_,
           op _*_   : Nat Nat -> Nat to _*N_,
           op _<_   : Nat Nat -> Bool to _<N_,
           op _<=_  : Nat Nat -> Bool to _<=N_,
           op _>=_  : Nat Nat -> Bool to _>=N_,
           op _>_   : Nat Nat -> Bool to _>N_,
           
           op _<_  : String String -> Bool to _<S_,   
           op _<=_ : String String -> Bool to _<=S_,   
           op _>_  : String String -> Bool to _>S_,   
           op _>=_ : String String -> Bool to _>=S_,  
           op _+_  : String String -> String to _+S_,
           
           op abs   : Float -> Float to absF,
           op -_    : Float -> Float  to -F_,
           op _+_   : Float Float -> Float to _+F_,
           op _-_   : Float Float -> Float to _-F_,
           op _/_   : Float Float -> Float to _/F_,
           op _*_   : Float Float -> Float to _*F_,
           op min   : Float Float -> Float to minF,
           op max   : Float Float -> Float to maxF,
           op _rem_ : Float Float -> Float to _remF_,
           op _^_   : Float Float -> Float to _^F_,
           op _<_   : Float Float -> Bool  to _<F_,
           op _<=_  : Float Float -> Bool  to _<=F_,
           op _>_   : Float Float -> Bool  to _>F_,
           op _>=_  : Float Float -> Bool  to _>=F_, 
           op floor : Float -> Float to floorF,
           op ceiling : Float -> Float to ceilingF,
           
           op _-_   : Int Int -> Int to _-I_,
           op -_ : Int -> Int to -I_,

           op _/_   : Rat Rat -> Rat  to _/R_,         
           op floor : PosRat -> Nat to floorR,
           op ceiling : PosRat -> Nat to ceilingR,
           
           op string : Qid -> String to qid2String,
           
           op _`,_ : TermList TermList -> TermList to _&&_ [gather (e E) prec 121],
           op empty : -> TermList to emptyTL,
           op _<-_ : Variable Term -> Assignment to _<-ML_,
           op __ : NatList NatList -> NatList to _;1_,
           op nil : -> NatList to nilNatList,
           op append : NatList NatList -> NatList to appendNL,
           op occurs : Nat NatList -> Bool to occursNL,
           op reverse : NatList -> NatList to reverseNL,
           op $reverse : NatList NatList -> NatList to $reverseNL,
           op head : NeNatList -> Nat to headNL,
           op tail : NeNatList -> NatList to tailNL,
           op last : NeNatList -> Nat to lastNL,
           op front : NeNatList -> NatList to frontNL,
           op size : NatList -> Nat to sizeNL,
           op $size : NatList Nat -> Nat to $sizeNL,
           op __ : QidList QidList -> QidList to _;2_,
           op nil : -> QidList to nilQidList,
           op append : QidList QidList -> QidList to appendQL,
           op occurs : Qid QidList -> Bool to occursQL,
           op reverse : QidList -> QidList to reverseQL,
           op $reverse : QidList QidList -> QidList to $reverseQL,
           op head : NeQidList -> Qid to headQL,
           op tail : NeQidList -> QidList to tailQL,
           op last : NeQidList -> Qid to lastQL,
           op front : NeQidList -> QidList to frontQL,
           op size : QidList -> Qid to sizeQL,
           op $size : QidList Qid -> Qid to $sizeQL,
           op _+_ : ModuleExpression ModuleExpression -> ModuleExpression to _+++_,
           op _:_ : Term Sort -> EqCondition to _:?_,
           op _=_ : Term Term -> EqCondition to _==?_,
           op [_] : Qid -> Module to `[`[`[_`]`]`],
           op _;_ : QidSet QidSet -> QidSet to _U1_,
           op _in_ : Qid QidSet -> Bool to _inQS_,
           op |_| : QidSet -> Nat to |_|QS,
           op union : QidSet QidSet -> QidSet to unionQS,
           op intersection : QidSet QidSet -> QidSet to intersectionQS,
           op metaNarrow : Module Term Term Qid Bound Nat ~> ResultTriple? to metaNarrow1,
           op metaNarrow : Module Term Qid Bound Bool Nat ~> ResultPair? to metaNarrow2,
           op {_,_} : Substitution Context -> MatchPair to mp`{_`,_`},
           op {_,_} : Substitution Nat -> UnificationPair to up`{_`,_`},
           
           op qid : String -> Qid to string2Qid
          ) .
endm

mod MODELPARSER is
	pr METAMODEL-PROP .
	pr MGMETA-LEVEL .
    pr MAP{String, Nat} 
        * (op _xor_ : Nat Nat -> Nat to _xorN_,
           op _|_   : Nat Nat -> Nat  to _|N_,    
           op _+_   : Nat Nat -> Nat to _+N_,
           op _*_   : Nat Nat -> Nat to _*N_,
           op _<_   : Nat Nat -> Bool to _<N_,
           op _<=_  : Nat Nat -> Bool to _<=N_,
           op _>=_  : Nat Nat -> Bool to _>=N_,
           op _>_   : Nat Nat -> Bool to _>N_,
           op _<_  : String String -> Bool to _<S_,   
           op _<=_ : String String -> Bool to _<=S_,   
           op _>_  : String String -> Bool to _>S_,   
           op _>=_ : String String -> Bool to _>=S_,  
           op _+_  : String String -> String to _+S_) .

---(
  	
  	vars  F MMQ : Qid .
  	var  Ct : Constant .
  	vars T T' : Term .
  	vars  TL TL2 : TermList .
  	vars  N CNT SZ : Nat .
  	var M : @Model .
	var MM : @Metamodel .
	var OBJSET : Set{@Object} .
  	var MSN : Map{String, Nat} .
  	vars STRING ST1 ST2 : String .
  	vars SS : MSet{OclExp} .

	--- PARSING A MODEL
	
	--- Partsings a @Model
	op parseModel : @Model -> String .
	eq parseModel(M) = parseModel(M, metamodelModule(M)) .
	
	--- The second argument is the Module on which the sort 
	--- of the recursive terms will be searched
	--- It needs to be specified when the @Model includes element
	--- not defined only in its metamodel (such as ActionExec elements)
	op parseModel : @Model Qid -> String .
	eq parseModel(M, MMQ) = parseModel(upTerm(M), termsTypes(M, MMQ), MMQ) .
	

	--- Parsing a term (upTerm of a @Model or @ClockedSystem)	
	op parseModel : Term -> String .
    eq parseModel(T) = parseModel(T, metamodelModule(T)) .
    
	--- We ignore timed constructs if applicable
	eq parseModel( _`[_`]( '_in`time_ , (_`[_`]( '`{_`} , T), T')))
	  = parseModel(T, metamodelModule(T)) .
	eq parseModel( _`[_`]( '_`{_`} , (Ct , T)) )
	  = parseModel(_`[_`]( '_`{_`} , (Ct , T)), metamodelModule(T)) .
	  
	op parseModel : Term Qid -> String . 
	---eq parseModel(T, MMQ) = parseModel( T, termsTypes(T, MMQ), MMQ) .
	eq parseModel( _`[_`]( '_in`time_ , (_`[_`]( '`{_`} , T), T')), MMQ)
	  = parseModel( T, termsTypes(T, MMQ), MMQ) .
	eq parseModel( _`[_`]( '_`{_`} , (Ct , T)), MMQ)
	  = parseModel( _`[_`]( '_`{_`} , (Ct , T)), 
	  			    termsTypes(_`[_`]( '_`{_`} , (Ct , T)), MMQ), MMQ) .
			 
 	op parseModel : Term Map{String, Nat} Qid -> String .     
	eq parseModel( _`[_`]( '_`{_`} , (Ct , T) ), MSN, MMQ)                           
      = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +S
          ("<xmi:XMI xmi:version=\"2.0\"\n" +S
            (tab(1) +S ("xmlns:xmi=\"http://www.omg.org/XMI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n" +S 
            (tab(1) +S ("xmlns=\"http://www.lcc.uma.es/MaudeMM/1.0\">\n" +S
		      --- A module for the sorts of the model terms
		      (tab(2) +S ("<SModule name=\"@AuxiliaryModule\" >\n" +S
		        (serializeSorts(MSN, 0, 3) +S
			  --- A module for the model terms
			  (tab(2) +S ("</SModule>\n" +S
			  (tab(2) +S ("<RecTerm op=\"_`{_`}\" type=\"#/0/@els." 
			  +S (string(MSN["@Model"], 10)  +S ("\">\n" +S
           	    --- Metamodel constant
			    (parseElement(Ct, 3, MSN, MMQ) +S
           		--- Set of objects
			    (parseElement(T, 3, MSN, MMQ) +S
			  (tab(2) +S ("</RecTerm>\n" +S
        "</xmi:XMI>\n")))))))))))))))))) .
     	 
	--- The second argument is the number of tabulators
	op parseElement : Term Nat Map{String, Nat} Qid -> String .
	eq parseElement(Ct, N, MSN, MMQ)
		= tab(N) +S ("<args xsi:type=\"Constant\" op=\"" 
		  +S (javaString(getName(Ct)) +S ("\" type=\"#/0/@els." 
		  +S ( string( MSN[toString(getType(Ct))], 10) +S "\"/>\n")))) .
	eq parseElement(_`[_`](F, TL), N, MSN, MMQ)
	  = if sortLeq(upModule(MMQ, false), 
	               leastSort(upModule(MMQ, false), _`[_`](F, TL)), 
	               'NzInt) 
	    then parseIntElement(_`[_`](F, TL), N, MSN, MMQ)
	    else if sortLeq(upModule(MMQ, false), 
	               leastSort(upModule(MMQ, false), _`[_`](F, TL)), 
	               'NzRat)
	    	 then parseElement( getTerm(metaReduce(upModule(MMQ, false), 
	    	                                       _`[_`]('rat2float, _`[_`](F, TL)))), 
	    	                    N, MSN, MMQ)
	    	 else tab(N) +S ("<args xsi:type=\"RecTerm\" op=\"" 
	         	  +S (javaString(F) +S ("\" type=\"#/0/@els." 
	         	  +S ( string( MSN[ toString( leastSort(upModule(MMQ, false) ,
	                                          _`[_`](F, TL)))], 10) 
	         	  +S ("\">\n" +S (parseElements(TL, s N, MSN, MMQ) 
	         	  +S (tab(N) +S "</args>\n")))))))
	         fi
	    fi .

	--- Parsing a list of terms 
	op parseElements : TermList Nat Map{String, Nat} Qid -> String .
	eq parseElements((T , TL), N, MSN, MMQ)  
      = parseElement(T, N, MSN, MMQ) +S parseElements(TL, N, MSN, MMQ) .
	eq parseElements(empty, N, MSN, MMQ) = "" .
	        
    --- Transforming natural (and ints) number to the same format 
    --- as the other data types
	op parseIntElement : Term Nat Map{String, Nat} Qid -> String .
	eq parseIntElement(_`[_`]('-_ , _`[_`](F, '0.Zero)), N, MSN, MMQ)
	  = tab(N) +S ("<args xsi:type=\"Constant\" op=\"" 
	    +S ( ("-" +S qidToNat(F)) +S ("\" type=\"#/0/@els." 
	    +S ( string( MSN["NzInt"], 10) +S "\"/>\n")))) .
	eq parseIntElement(_`[_`]('-I_ , _`[_`](F, '0.Zero)), N, MSN, MMQ)
	  = tab(N) +S ("<args xsi:type=\"Constant\" op=\"" 
	    +S ( ("-" +S qidToNat(F)) +S ("\" type=\"#/0/@els." 
	    +S ( string( MSN["NzInt"], 10) +S "\"/>\n")))) .
	eq parseIntElement(_`[_`](F, '0.Zero), N, MSN, MMQ)
	  = tab(N) +S ("<args xsi:type=\"Constant\" op=\"" +S ( qidToNat(F) 
	    +S ("\" type=\"#/0/@els." +S ( string( MSN["NzNat"], 10) 
	    +S "\"/>\n")))) .
		  	
 	op serializeSorts : Map{String, Nat} Nat Nat -> String .
 	eq serializeSorts((ST1 |-> CNT, MSN), CNT, N) = 
 		tab(N) +S ("<els xsi:type=\"Sort\" name=\"" +S ( javaString(ST1) 
 		+S ("\"/>\n" +S serializeSorts((ST1 |-> CNT, MSN), CNT + 1, N)))) .
 	eq serializeSorts(MSN, CNT, N) = "" [owise] . 

	--- OBTAINING TERMS TYPES 
	--- Obtains all terms types and add them a identifier (number) 
	--- to be able to refer to them from the terms
	
	op termsTypes : @Model -> Map{String, Nat} .
	eq termsTypes(M) = termsTypes(M, metamodelModule(M)) .
	
	--- We add the FiniteFloat type in case we convert from rat to float
	op termsTypes : @Model Qid -> Map{String, Nat} .
	eq termsTypes(M, MMQ) = toIndexedMap( union("FiniteFloat",termType(upTerm(M), MMQ)), 0) .
	
	op termsTypes : Term Qid -> Map{String, Nat} .
	eq termsTypes(T, MMQ) = toIndexedMap( union("FiniteFloat",termType(T, MMQ)), 0) .

	op termType : Term Qid ~> Set .
	eq termType(Ct, MMQ) = Set{ toString(getType(Ct)) } .
	eq termType(_`[_`](F, TL), MMQ)
	  = union(Set{ toString(leastSort(upModule(MMQ, false), _`[_`](F, TL))) },
	    	  termsTypeList(TL, MMQ)) . 
	
	op termsTypeList : TermList Qid ~> Set .
	eq termsTypeList((T , TL), MMQ) 
	  = union(termType(T, MMQ), termsTypeList(TL, MMQ)) .
    eq termsTypeList(empty, MMQ) = Set{mt} .

	--- (Predefined Maude counter can not be used in equations, only in rules)
	op toIndexedMap : Set Nat -> Map{String, Nat} .
	eq toIndexedMap(Set{ST1 ; SS}, N) = (ST1 |-> N), toIndexedMap(Set{SS}, N + 1) . 
	eq toIndexedMap(Set{mt}, N) = empty .

	 		
	--- AUXILIARY OPERATIONS
	
	--- Obtain the Maude module of the metamodel the model conforms to
	op metamodelModule : @Model -> Qid .
	eq metamodelModule(M) 
	  = qid(toUpper(toString(getName(upTerm(meta(M)))))) .
	
	op metamodelModule : Term ~> Qid .
	eq metamodelModule( _`[_`](F,(T, TL)) ) 
	  = qid(toUpper(toString(getName(T)))) .
	
	--- Add n tabulators
	op tab : Nat -> String .
	eq tab(0) = "" .
	eq tab(s N) = "\t" +S tab(N) .
	
	--- Map function
	op $hasMapping : Map{String, Nat} String -> Bool .
	eq $hasMapping((MSN, ST1 |-> N), ST1) = true .
	eq $hasMapping(MSN, ST1) = false [owise] .
	
	--- Converts a Qid that represents a Nat to its corresponding String value
	op qidToNat : Qid -> String .
	eq qidToNat('s_) = "1" .
	eq qidToNat(F) = substr(toString(F),3,length(toString(F))) [owise] .

 	--- Converts a Qid to a String element replacing 
 	--- "<" with "&lt" and """ with "%quot"
 	op javaString : Qid -> String .
 	eq javaString(F) = javaString(toString(F)) .

 	op javaString : String -> String .
 	eq javaString(ST1) 
 	  = replaceAll( replaceAll(ST1,"<","&lt;"), "\"", "&quot;") .
 	 	
 	op replaceAll : String String String -> String .
 	eq replaceAll(STRING, ST1, ST2)
 	  = if (find(STRING, ST1,0) == notFound) 
 		then STRING
 		else substr(STRING,0,find(STRING, ST1,0)) +S (ST2 +S 
 			 replaceAll(substr(STRING,find(STRING, ST1,0) + length(ST1), 
 			                   length(STRING)), ST1, ST2)) 
 		fi .
  		
 	op toUpper : String -> String . 
 	eq toUpper(ST1) 
 	  = if (ST1 == "")  
 	    then ""
 	    else if ((ascii(substr(ST1,0,1)) <= 122) 
 	            and-then (97 <= ascii(substr(ST1,0,1))))
 		     then char(_-_(ascii(substr(ST1,0,1)),32)) --- lower case
 		     else substr(ST1,0,1) fi 				   --- owise
		     +S toUpper(substr(ST1,1,length(ST1))) fi .
---)
endm

red 99 .

mod MAUDELING is
  pr MGMODEL-CHECKER * (
		op _lt_  : String String -> Bool to _ltS_,
        op _gt_  : String String -> Bool to _gtS_ )  .
  pr MODELCONFORMANCE * (
		op _lt_  : String String -> Bool to _ltS_,
        op _gt_  : String String -> Bool to _gtS_ )  .
  pr MODELPARSER * (
		op _lt_  : String String -> Bool to _ltS_,
        op _gt_  : String String -> Bool to _gtS_ )  .
endm