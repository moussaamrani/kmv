cd /cygdrive/f/Workspace/Maude/KMV/
load syntax/model-checker.maude 
load syntax/mmOdCL.maude
load syntax/MMGDefinitions.maude


view @Class from TRIV to METAMODEL-CTORS is
  sort Elt to @Class .
endv

mod KERMETA-STMT-PREP is
	sort @Statement .
endm

mod KERMETA-SL-CTORS is
	pr METAMODEL-PROP .
	pr MGLIST{@NamedElement} * (sort MGList{@NamedElement} to MyList) .

	pr MGMAYBE{@Class} . 

	--- Operation & Parameters signature
	sort @Operation @Parameter @Variable @LocalVariable .
	subsort @Variable @Parameter < @LocalVariable < Vid .
	subsort @Operation @Parameter @LocalVariable < @StructuralFeature .
	op self : -> @LocalVariable .
	op operations : @Class -> MyList . --- of @Operation
	op isAbstract : @Operation -> Bool .
	op from : @StructuralFeature -> Maybe{@Class} .
	op containingOperation : @Parameter -> @Operation .
	op containingOperation : @Variable  -> @Operation .
   	op parameters : @Operation -> MyList . --- of @Parameter
	op variables : @Operation -> MyList .  --- of @Variable
					
	--- Label
	sort @Label @LabelNxt .
	op [_,_,_,_] : @Package @Class @Operation Nat -> @Label [ctor] .
	--- default label
	op [] : -> @Label .
	op <_,_> : @Label @Label -> @LabelNxt [ctor] .
	op nxt : @Label -> @LabelNxt .
	op labels : @Operation -> MyList . --- of @Label
	
	var LV : @LocalVariable .
	op defaultValue : @LocalVariable -> OCL-Type .
	eq defaultValue(LV) = 
		if isMany(LV) then
			if isOrdered(LV) then
				if isUnique(LV) then
					OrderedSet{}
				else
					Sequence{}
				fi
			else
				if isUnique(LV) then
					Set{}
				else
					Bag{}
				fi
			fi
		else 
			if type(LV) :: @DataType then
				defaultValue(type(LV))
			else
				null
			fi
		fi .
endm

view @Label from TRIV to KERMETA-SL-CTORS is
  	sort Elt to @Label .
endv

view @Statement from TRIV to KERMETA-STMT-PREP is
 	sort Elt to @Statement .
endv

view @Operation from TRIV to KERMETA-SL-CTORS is
 	sort Elt to @Operation .
endv

view @LocalVariable from TRIV to KERMETA-SL-CTORS is
	sort Elt to @LocalVariable .	
endv

view OCL-Type from TRIV to MGmOdCL is
    sort Elt to OCL-Type .
endv

mod KERMETA-STATEMENTS-MAP is
	pr MAP{@Label, @Statement} .
	pr MAP{@LocalVariable, OCL-Type} .
endm

mod KERMETA-SL is
	pr KERMETA-SL-CTORS .
	pr KERMETA-STATEMENTS-MAP .
	op statements : @Metamodel -> Map{@Label, @Statement} .
endm

--- ------------------------------------------------------------------------------------
--- Action Language Syntax
--- 
--- Body ::= [Stm]+
--- Stm  ::= lab: Stmt
--- Stmt ::= condStmt 
---       |  assignStmt | castStmt
---       |  instanceCreationStmt 
---       |  collStmt
---       |  returnStmt | callStmt 
--- CondStmt             ::= <if> exp
--- AssignStmt           ::= lhs := exp
--- InstanceCreationStmt ::= var := exp
--- ReturnStmt           ::= <return> | <return> exp
--- CallStmt             ::= call | var := call
--- Call                 ::= target.op(exp*)
--- ------------------------------------------------------------------------------------
mod KERMETA-AL is
	pr KERMETA-STMT-PREP .
	pr KERMETA-SL .
    pr METAMODEL-PROP .
    pr MGMAYBE{@Operation} .
                
	sort    @CondStmt @AssignStmt @InstanceCreationStmt @Call @CallStmt @ReturnStmt .
	subsort @Call < @CallStmt .
	subsort @CondStmt @AssignStmt @InstanceCreationStmt @CallStmt @ReturnStmt < @Statement .
	sort    @CollItem .
	
	ops bag
		set
		seq
		oset : -> @CollItem .
	op iff_      : OCL-Exp -> @CondStmt [ctor] .
   	op _.:=._      : OCL-Exp OCL-Exp -> @AssignStmt [ctor] .
   	op _.:=. new`(_`) : @Variable @Classifier -> @InstanceCreationStmt [ctor] .
   	op _.:=. new`(_,_`) : @Variable @CollItem @Classifier -> @InstanceCreationStmt [ctor] .
   	op return    : -> @ReturnStmt [ctor] .
   	op return_   : OCL-Exp -> @ReturnStmt [ctor] .
   	op _._<>   : OCL-Exp String -> @Call [ctor prec 15] .
   	op _._<_>   : OCL-Exp String List{OCL-Exp} -> @Call [ctor] .
   	op _.:=._    : OCL-Exp @Call -> @CallStmt [ctor] .
   	
   	var CLASSIFIER : @Classifier .
   	op default(_,_) :  @CollItem @Classifier -> OCL-Exp .
   	eq default(bag,  CLASSIFIER) = Bag{} .
   	eq default(set,  CLASSIFIER) = Set{} .
   	eq default(seq,  CLASSIFIER) = Sequence{} .
   	eq default(oset, CLASSIFIER) = OrderedSet{} .
   	
   	var ON : String .
   	var C  : @Class .
   	var O : @Operation .
   	var L VALLIST PARAMLIST : MyList .
   	var LV VAL PARAM : @LocalVariable .
   	vars VPAIRS VPAIRSS VPSET : Set{VarPair} .
   	var VPELT : VarPair .
   	
   	op createLocalEnv : @Operation -> Set{VarPair} .
   	eq createLocalEnv(O) = createLocalEnv$(variables(O)) .
   	
   	op createLocalEnv$ : MyList -> Set{VarPair} . --- of @Variable
   	eq createLocalEnv$(nil) = empty .
   	eq createLocalEnv$(LV L) = putVar(LV <- defaultValue(LV), createLocalEnv$(L)) .
   	
	op createParamBinding : List{OCL-Exp} MyList -> Set{VarPair} .
	eq createParamBinding(mt-ord, nil)  = empty .
	eq createParamBinding((VAL # VALLIST), (PARAM PARAMLIST)) = putVar(PARAM <- VAL, createParamBinding(VALLIST, PARAMLIST)) .
  	
   	
   	op lookup : String @Class -> @Operation .
   	eq lookup(ON , C) = 
   		if(not ( getByName(ON , C) == null )) then
   			getByName(ON , C)
   		else 
   			findByName(ON , allSuperTypes(C) )
   		fi
   	.
   	
   	op findByName : String MyList -> @Operation . --- of @Class
   	eq findByName(ON , C) = getByName(ON , C) .
 	eq findByName(ON , C L) = 
 		if(not (getByName(ON , C) == null)) then
 	 		getByName(ON , C)
 	 	else
 	 		findByName(ON , L)
 	 	fi
 	 .
   	
   	op getByName : String @Class -> Maybe{@Operation} . 
   	eq getByName(ON , C) = getByName$(ON , operations(C)) .
   	 
   	op getByName$ : String MyList -> Maybe{@Operation} . --- of @Operation
   	eq getByName$(ON , nil) = null .
   	eq getByName$(ON , O L) = 
   		if (ON == name(O)) then
   			O
   		else
   			getByName$(ON , L)
   		fi 
   	.
   	
endm



mod KERMETA-DOMAIN is
	pr MGmOdCL .
	pr METAMODEL-PROP .
	pr KERMETA-SL-CTORS .
	---pr MAP{@LocalVariable, OclType} .
	sort Domain .
	op <_##_> : @Model Set{VarPair} -> Domain [ctor] .
		
endm

mod KERMETA-STACK is
	pr KERMETA-SL .
	pr KERMETA-STATEMENTS-MAP .
	pr MGMAYBE{@LocalVariable} .	
	
	sort StackEntry .
	op `(|_,_,_|`) : @Label Set{VarPair} Maybe{@LocalVariable} -> StackEntry .
endm

fmod STACK{X :: TRIV} is
	protecting BOOL .

	sorts NeStack{X} Stack{X} .
	subsort X$Elt  < NeStack{X} < Stack{X} .

	op NOPE : -> Stack{X} [ctor] .
	op _!!!_ : X$Elt Stack{X} -> NeStack{X} [ctor] .

	var E : X$Elt .
	var S : Stack{X} .
	eq (E !!! NOPE)  = E .
	
	op isEmpty_ : Stack{X} -> Bool .
	eq isEmpty(NOPE) = true .
	eq isEmpty(S)    = false [owise] .
	
endfm



view StackEntry from TRIV to KERMETA-STACK is
	sort Elt to StackEntry .
endv

mod KERMETA-CONFIGURATION is
	pr KERMETA-SL .
	pr STACK{StackEntry} .
	pr KERMETA-DOMAIN .
	
	sort KConfig .
	op <|_,_,_,_|> : @Label Stack{StackEntry} Domain Nat -> KConfig .
	
	var LAB : @Label .
	var S : Stack{StackEntry} .
	var N : Nat .
	var D : Domain .
	
	op isStop : KConfig -> Bool .
	eq isStop(<| [], S, D, N |>) = isEmpty(S) .
	eq isStop(<| LAB, S, D, N |>) = false [owise] .
endm

mod KERMETA is

	pr KERMETA-AL .
	pr KERMETA-CONFIGURATION .
	
	
	var N : Nat .
	vars LAB LABNxt LABE LABT LABNULL : @Label .
	vars D : Domain .
	vars VPSET VPSETT : Set{VarPair} .
	vars M MP : @Model .
	vars MM : @Metamodel .
	var SFIS : Set{@StructuralFeatureInstance} .
	vars S : Stack{StackEntry} .
	vars E RES INST O : OCL-Exp .
	vars MYVAR : @Variable .
	var MAYBEVAR : Maybe{@LocalVariable} .
	var CLASS : @Class .
	var CLASSIFIER : @Classifier .
	var OBJSET : Set{@Object} .
	var SE : StackEntry .
	var COLLITEM : @CollItem .
	var OPNAME : String .
	var OP : @Operation . 
	var LO LEXP : List{OCL-Exp} .
	var K : KConfig .
	
	op newOid : Nat -> Oid .
	
	var VAR : @Variable .
	eq newOid(N) = qid("O" + string(N, 10)) .
	
	op run : KConfig -> KConfig .
	eq run(K) = if isStop(K) then K else run(exec(K)) fi .
	
	
	op exec : KConfig -> KConfig .
	ceq exec( <| LAB, S, < M ## VPSET >, N |> ) = <| LABT, S, < M ## VPSET >, N |> 
		if  iff( E ) := statements( meta(M) ) [ LAB ] /\ < LABT , LABE > := nxt(LAB)
			 /\ true = << E ; env(VPSET) ; M >> 	
	.
	ceq exec(<| LAB, S, < M ## VPSET >, N |>) = <| LABE, S, < M ## VPSET >, N |> 
		if  iff( E ) := statements( meta(M) ) [ LAB ] /\ 
			< LABT , LABE > := nxt(LAB) /\ false = << E ; env(VPSET) ; M >> 
	.
	
	ceq exec(<| LAB, S, < MM { OBJSET } ## VPSET >, N |>) = <| LABNxt, S, < MM { complete(< newOid(N) : CLASSIFIER | empty >) OBJSET } ## (putVar(MYVAR <- newOid(N), VPSET)) >, (N + 1) |>
			if  MYVAR .:=. new ( CLASSIFIER ) := statements( MM ) [ LAB ] /\ CLASSIFIER :: @Class /\ 
			< LABNxt , LABNULL > := nxt(LAB)
	.
	ceq exec(<| LAB, S, < MM { OBJSET } ## VPSET >, N |>) = <| LABNxt, S, < MM { OBJSET } ## (putVar(MYVAR <- defaultValue(CLASSIFIER), VPSET)) >, N |>
			if  MYVAR .:=. new ( CLASSIFIER ) := statements( MM ) [ LAB ] /\ CLASSIFIER :: @DataType /\ 
			< LABNxt , LABNULL > := nxt(LAB)
	.
	
	ceq exec(<| LAB, S, < MM { OBJSET } ## VPSET >, N |>) = <| LABNxt, S, < MM { OBJSET } ## (putVar(MYVAR <- default(COLLITEM , CLASSIFIER), VPSET)) >, N |>
			if  MYVAR .:=. new ( COLLITEM , CLASSIFIER ) := statements( MM ) [ LAB ] /\ 
			< LABNxt , LABNULL > := nxt(LAB)
	.
	
	ceq exec(<| LAB, (| LABNxt , VPSETT, null |) !!! S, < M ## VPSET >, N |>) = <| LABNxt, S, < M ## VPSETT >, N |> if
		return :=  statements( meta(M) ) [ LAB ]
	.
	ceq exec(<| LAB, (| LABNxt , VPSETT, MYVAR |) !!! S, < M ## VPSET >, N |>) = <| LABNxt, S, < M ## VPSETT >, N |> if
		return( E ) :=  statements( meta(M) ) [ LAB ] /\
		RES := << E ; env(VPSET) ; M >>
	. --- evaluate E within VPSET, then update MYVAR inside VPSETT
	
	
	ceq exec(<| LAB, S, < MM { < O : CLASS | SFIS > OBJSET } ## VPSET >, N |>) = 
			 <| [ package(containingClass(OP)) , containingClass(OP) , OP , 1 ] , (| LABNxt , VPSET, null |) !!! S, < MM { OBJSET } ## (putVar(self <- O, createLocalEnv(OP))) >, N |>
		if INST . OPNAME <> := statements( MM ) [ LAB ] /\
		< LABNxt , LABNULL > := nxt(LAB) /\
		O := << INST ; env(VPSET) ; MM { < O : CLASS | SFIS > OBJSET } >> /\ O :: Oid /\
		OP := lookup(OPNAME, CLASS) 
	.
	ceq exec(<| LAB, S, < MM { < O : CLASS | SFIS > OBJSET } ## VPSET >, N |>) = 
			 <| [ package(containingClass(OP)) , containingClass(OP) , OP , 1 ] , (| LABNxt , VPSET, null |) !!! S, < MM { OBJSET } ## (putVar(self <- O, createLocalEnv(OP))) >, N |>
		if INST . OPNAME < LO > := statements( MM ) [ LAB ] /\
		< LABNxt , LABNULL > := nxt(LAB) /\
		LEXP := eval-EL(LO, env(VPSET), none) /\
		O := << INST ; env(VPSET) ; MM { < O : CLASS | SFIS > OBJSET } >> /\ O :: Oid /\
		OP := lookup(OPNAME, CLASS) 
	.

endm